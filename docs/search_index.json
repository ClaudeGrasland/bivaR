[["index.html", "Introduction à la statistique bivariée et aux représentations graphiques avec R À propos de ce document Remerciements Licence", " Introduction à la statistique bivariée et aux représentations graphiques avec R Claude Grasland 2022-01-11 À propos de ce document Ce document n’est pas une introduction aux méthodes statistiques d’analyse de données. Il est basé sur R version 4.0.2 (2020-06-22). Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse : https://github.com/ClaudeGrasland/bivaR Le code source est disponible sur GitHub. Pour toute suggestion ou correction, il est possible de me contacter par mail Remerciements Ce document est généré par l’ extension bookdown de Yihui Xie, complétée par les ajouts de Julien Barnier (css, javascript, …) dans son Introduction à R et au Tidyverse Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Licence Creative Commons "],["01-principes.html", "Partie 1 Chapitre 1 : Principes du langage R 1.1 Opérations arithmétiques 1.2 Les objets de base : valeur, vecteur, matrice 1.3 Ne pas confondre listes et vecteurs ! 1.4 Attention aux types de variables … 1.5 Types de tableaux et guerres de religion. 1.6 En résumé 1.7 Exercices", " Partie 1 Chapitre 1 : Principes du langage R 1.1 Opérations arithmétiques Nous allons commencer par passer quelques commandes arithmétiques simples. Il suffit de les taper dans la console de R pour qu’elles s’executent automatiquement. 8+2 #&gt; [1] 10 8-2 #&gt; [1] 6 8*2 #&gt; [1] 16 8/2 #&gt; [1] 4 8**2 #&gt; [1] 64 8**(1/2) #&gt; [1] 2.828427 log(10) #&gt; [1] 2.302585 log10(10) #&gt; [1] 1 sqrt(10) #&gt; [1] 3.162278 sin(pi) #&gt; [1] 1.224647e-16 cos(pi) #&gt; [1] -1 tan(pi) #&gt; [1] -1.224647e-16 1.2 Les objets de base : valeur, vecteur, matrice Les objets élémentéires de R apparaissent dans la fenêtre environnement sous la rubrique Values 1.2.1 Eléments Un élément est unique et constitue la brique de base de tous les objets suivants. On peut aussi l’interpréter comme un vecteur de longueur 1 ou une matrice de dimension 1x1. x&lt;-8 y&lt;-2 x+y #&gt; [1] 10 x*y #&gt; [1] 16 x**y #&gt; [1] 64 Les éléments se combinent différemment selon leur type. Par exemple, des éléments de type caractère (character) peuvent être assemblés avec l’instruction paste() ou découpez avec l’instruction substr() : x&lt;-&quot;Bonjour&quot; y&lt;- &quot;tout le monde&quot; z&lt;- &quot;!&quot; paste(x,y,z) #&gt; [1] &quot;Bonjour tout le monde !&quot; substr(x,1,3) #&gt; [1] &quot;Bon&quot; Quant aux éléments logiques (logical) nous verrons qu’ils peuvent se combiner avec des opérateurs comme &amp; quii signifie ET ou bien | qui signifie OU. x&lt;-TRUE y&lt;-FALSE x &amp; y #&gt; [1] FALSE x | y #&gt; [1] TRUE 1.2.2 vecteurs (vectors) Un vecteur est un ensemble d’éléments de même type que l’on a concaténés à l’aide de l’instruction c(). On peut ensuite les aditionner, les multiplier ou les combiner avec des éléments. x &lt;- c(1,2,4,8,16) y &lt;- 4 x+y #&gt; [1] 5 6 8 12 20 x*y #&gt; [1] 4 8 16 32 64 x**y #&gt; [1] 1 16 256 4096 65536 On remarque dans l’exemple ci-dessus que R n’a pas de problème pour combiner des vecteurs de tailles différentes. 1.2.3 Matrices (matrix) Une matrice est un ensemble de vecteurs de même longueur et de même type. On peut donc construire une matrice en concaténant des vecteurs verticalement avec cbind()ou horizontalement avec rbind(). # deux vecteurs x1 &lt;- c(1,2,4,8,16) x2 &lt;- c(5,10,15,20,25) # matrice en colonnes m1 &lt;- cbind(x1,x2) m1 #&gt; x1 x2 #&gt; [1,] 1 5 #&gt; [2,] 2 10 #&gt; [3,] 4 15 #&gt; [4,] 8 20 #&gt; [5,] 16 25 # matrice en lignes m2 &lt;- rbind(x1,x2) m2 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; x1 1 2 4 8 16 #&gt; x2 5 10 15 20 25 # piège ! m3 &lt;- c(x1,x2) m3 #&gt; [1] 1 2 4 8 16 5 10 15 20 25 is.matrix(m3) #&gt; [1] FALSE Si on assemble deux vecteurs à l’aide de la commande c()on obtient un vecteur et pas une matrice. 1.3 Ne pas confondre listes et vecteurs ! R utilise des types plus complexes d’objets qui lui sont propres et qui sont en général des listes ou des listes de listes. liste simple liste de liste listes de vecteur = data.frame … Les vecteurs regroupent des éléments de même type tandis que les listes regroupent des éléments ou des objets de type quelconque. Le type liste est donc beaucoup plus général, mais aussi plus difficile d’emploi. On peut comparer une liste à un panier de course dans lequel on mélange des choux, des carottes, des navets, une boîte de douze oeufs, un paquet de croquettes pour chiens, etc… # Format vecteur prenom &lt;- c(&quot;Ali&quot;, &quot;Amine&quot;, &quot;Anne&quot;,&quot;Marc&quot;,&quot;Zayneb&quot;) sexe &lt;- c(&quot;H&quot;,&quot;H&quot;,&quot;F&quot;,&quot;H&quot;,&quot;F&quot;) age &lt;- c(21,22,24,18,25) # Format liste Ali &lt;- list(&quot;H&quot;,21) Amine &lt;- list(&quot;F&quot;,22) Anne &lt;- list(&quot;F&quot;,28) Marc &lt;- list (&quot;H&quot;,18) Zayneb &lt;- list(&quot;F&quot;,25) # Ne pas confondre ! Ali &lt;- c(&quot;H&quot;,21) Ali #&gt; [1] &quot;H&quot; &quot;21&quot; Ali &lt;- list(&quot;H&quot;,21) Ali #&gt; [[1]] #&gt; [1] &quot;H&quot; #&gt; #&gt; [[2]] #&gt; [1] 21 1.4 Attention aux types de variables … Chaque valeur, vecteur ou matrice appartient à un seul type de données. Il est important de ne pas les confondre, sous peine d’obtenir des résultats … douteux. On se limitera ici aux principaux types, d’autres étant vus ultérieurement dans l’année : numeric : type général (entier, réels, …) logique : type booleen (TRUE/FALSE) date : année, mois, jour,n heure, minutes, secondes, … character : texte quelconque factor : variable catégorielle (codage d’enquêtes …) La commande str() permet de vérifier le type d’un vecteur (ou d’une matrice) et d’en afficher la dimension. # Format charactère prenom &lt;- c(&quot;Ali&quot;, &quot;Amine&quot;,&quot;Anne&quot;, &quot;Marc&quot;,&quot;Zayneb&quot;) str(prenom) #&gt; chr [1:5] &quot;Ali&quot; &quot;Amine&quot; &quot;Anne&quot; &quot;Marc&quot; &quot;Zayneb&quot; # Format logique likeR &lt;- c(TRUE,FALSE, TRUE, FALSE, FALSE) str(likeR) #&gt; logi [1:5] TRUE FALSE TRUE FALSE FALSE # Format Factor sexe &lt;- c(1,1,2,1,2) sexe&lt;-as.factor(sexe) levels(sexe) &lt;-c(&quot;Homme&quot;,&quot;Femme&quot;) str(sexe) #&gt; Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 1 1 2 1 2 # Format numerique age &lt;- c(21,22,24,18,25) str(age) #&gt; num [1:5] 21 22 24 18 25 # Format date nais&lt;-c(&quot;1999-10-28&quot;,&quot;1998-10-13&quot;, &quot;1996-10-15&quot;,&quot;2002-02-07&quot;,&quot;1995-06-18&quot;) nais&lt;-as.Date(nais) str(nais) #&gt; Date[1:5], format: &quot;1999-10-28&quot; &quot;1998-10-13&quot; &quot;1996-10-15&quot; &quot;2002-02-07&quot; &quot;1995-06-18&quot; 1.5 Types de tableaux et guerres de religion. R est un langage qui a beaucouop évolué au cours du temps, suscitant l’apparition de nouveaux types d’objets mieux adapéts à certaines fonctions. Du coup, il existe plusieurs format de tableaux de données, plus ou moins compatibles entre eux. On notera que dans la fenêtre environnement, les tableaux apparaissent dans la sous-fenêtre data et non plus dans la sous-fenêtre values comme c’était le cas pour les éléments, vecteurs ou matrices. 1.5.1 Le type data.frame : C’est le type d’origine correspondant à ce qu’on appelle le langage R-Base. Il se présente en pratique comme une liste de vecteurs qui peuvent être de types différents mais qui sont de même longueur. # Création d&#39;un data.frame tab1&lt;-data.frame(prenom,nais, age,sexe,likeR) str(tab1) #&gt; &#39;data.frame&#39;: 5 obs. of 5 variables: #&gt; $ prenom: chr &quot;Ali&quot; &quot;Amine&quot; &quot;Anne&quot; &quot;Marc&quot; ... #&gt; $ nais : Date, format: &quot;1999-10-28&quot; &quot;1998-10-13&quot; ... #&gt; $ age : num 21 22 24 18 25 #&gt; $ sexe : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 1 1 2 1 2 #&gt; $ likeR : logi TRUE FALSE TRUE FALSE FALSE 1.5.2 Le type tibble c’est un type créé par Hadley Wickham pour développer la suite de fonctions Tidyverse ou ggplot # Création d&#39;un tibble library(tidyr, quiet=T) tab2&lt;-tibble(prenom,nais, age,sexe,likeR) str(tab2) #&gt; tibble [5 × 5] (S3: tbl_df/tbl/data.frame) #&gt; $ prenom: chr [1:5] &quot;Ali&quot; &quot;Amine&quot; &quot;Anne&quot; &quot;Marc&quot; ... #&gt; $ nais : Date[1:5], format: &quot;1999-10-28&quot; &quot;1998-10-13&quot; ... #&gt; $ age : num [1:5] 21 22 24 18 25 #&gt; $ sexe : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 1 1 2 1 2 #&gt; $ likeR : logi [1:5] TRUE FALSE TRUE FALSE FALSE 1.5.3 Le type data.table C’est un type récent créé pour traiter les tableaux de très grande taille à l’aide du package … data.table # Création d&#39;un data.table library(data.table, quiet=T) tab3&lt;-data.table(prenom,nais, age,sexe,likeR) str(tab3) #&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;: 5 obs. of 5 variables: #&gt; $ prenom: chr &quot;Ali&quot; &quot;Amine&quot; &quot;Anne&quot; &quot;Marc&quot; ... #&gt; $ nais : Date, format: &quot;1999-10-28&quot; &quot;1998-10-13&quot; ... #&gt; $ age : num 21 22 24 18 25 #&gt; $ sexe : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 1 1 2 1 2 #&gt; $ likeR : logi TRUE FALSE TRUE FALSE FALSE #&gt; - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 1.6 En résumé R est un langage de programmation multifonction qui évolue depuis maintenant plus de 30 ans et auquel s’ajoutent continuellement de nouveaux packages. A la différence de SPSS, il n’est pas spécialisé uniquement en statistique, même si le coeur du logiciel est bien centré sur la statistique. Pour progresser rapidement en R il est indispensable : de prêter une grande attention aux types de variables et de tableaux. de ne pas chercher à utiliser trop vite de nouveaux packages tant que l’on n’a pas acquis une pratique suffisante du R-Base. de consulter la documentation et les forums de discussion en cas de difficulté. 1.7 Exercices Exercice 1 Construire le vecteur x suivant : #&gt; [1] &quot;Paris&quot; &quot;Londres&quot; &quot;Tokyo&quot; &quot;New York&quot; x &lt;- c(&quot;Paris&quot;, &quot;Londres&quot;,&quot;Tokyo&quot;,&quot;New York&quot;) Construire le vecteur y suivant : #&gt; [1] &quot;France&quot; &quot;Royaume-Uni&quot; &quot;Japon&quot; &quot;USA&quot; y &lt;- c(&quot;France&quot;, &quot;Royaume-Uni&quot;,&quot;Japon&quot;,&quot;USA&quot;) Construire le vecteur z suivant : #&gt; [1] 10.2 14.6 42.8 23.9 z &lt;- c(10.2, 14.6,42.8,23.9) Construire la matrice m1 #&gt; [,1] [,2] [,3] [,4] #&gt; x &quot;Paris&quot; &quot;Londres&quot; &quot;Tokyo&quot; &quot;New York&quot; #&gt; y &quot;France&quot; &quot;Royaume-Uni&quot; &quot;Japon&quot; &quot;USA&quot; m1&lt;-rbind(x,y) Construire le data.frame df #&gt; y x z #&gt; 1 France Paris 10.2 #&gt; 2 Royaume-Uni Londres 14.6 #&gt; 3 Japon Tokyo 42.8 #&gt; 4 USA New York 23.9 df&lt;-data.frame(y,x,z) Exercice 2 (d’après J.Barnier) On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage. revenu_total &lt;- conjoint1 + conjoint2 revenu_total / nb_personnes "],["02-initiation.html", "Partie 2 Chapitre 2 : Office killer ! 2.1 Rstudio et les projets R 2.2 Programme R : Excel killer ? 2.3 Document Rmd : Word killer ? 2.4 En résumé 2.5 Exercices", " Partie 2 Chapitre 2 : Office killer ! library(knitr) Cette initiation est destinée à des étudiants n’ayant jamais utilisé R mais connaissant à peu près la statistique univariée et bivariée… L’idée pédagogique est d’apprendre directement aux étudiants à programmer en R markdown plutôt qu’en R. Pourquoi ? Parce qu’ainsi ils vont simultanément : taper du code R qu’ils ignorent écrire sous ce code les explications du point de vue informatique observer les résultats statistiques interpréter ces résultats d’un point de vue statistique Cela n’a l’air de rien, mais en procédant ainsi les étudiants apprennent à produire à la fois leurs notes de cours en R, leurs notes de cours en statistiques et … le langage Rmarkdown pour rédiger leurs futurs travaux. Bref, si tout a bien marché, l’étudiant n’aura même pas besoin de consulter le présent document, si ce n’est pour vérifier que son programme donne les mêmes résultats … Les deux exercices qui suivent utilisent volontairement les fonctions de base du langage R (on dit que l’on programme en R-base) à l’exclusion de tout package c’est-à-dire de tout outil graphique ou statistique mis au point ultérieurement. Par comparaison avec le jeu de lego, cela revient à effectuer des constructions avec la boîte de base. A première vue cela peut sembler frustrant. Mais en réalité cela ne bride en rien l’imagination et permet d’apprendre plein de choses sans être distrait … 2.1 Rstudio et les projets R Au commencement, les dieux de la statistique créèrent le langage R. Mais l’interface était vide et vague, les ténèbres couvraient les lignes de code R-Studio dit : Que le projet soit et le projet fut. Si l’on veut s’épargner bien des désagréments dans l’apprentissage de R, il faut prendre dès le départ de bonnes habitudes. Parmi celles-ci, l’une des plus importantes est le fait d’inscrire toujours son travail dans le cadre d’un projet R c’est-à-dire - en simplifiant beaucoup - un répertoire de travail contenant l’ensemble des données, programmes, résultats… que l’on pourra par la suite compresser, archiver et transmettre à quelqu’un d’autre. 2.1.1 Lancement de R studio Sauf à être complètement masochiste, on n’utilise jamais R directement mais on lance d’abord l’interface R-Studio qui facilite conisdérablement l’ensemble des opérations et offre une gamme considérable de services. Il ne faut toutefois pas confondre les deux et il serait par exemple ridicule d’indiquer sur un CV en vue d’un emploi de statisticien que l’on sait utiliser R-studio en oubliant de préciser que l’on maîtrise R. 2.1.2 Création d’un projet Pour créer un projet on utilise le menus déroulant File/new project/ … et on définit un dossier de notre ordinateur (existant ou à créer) qui contiendra le projet. Une fois l’opération effectuée, on pourra constater que ce dossier contient un fichier xxx.Rproj ou xxx est en principe le nom du dossier dans lequel vous avez stocké le projet. Ce fichier contient toute une série d’informations dont nous ne parlerons pas dans ce cours d’initiation mais qui, pour faire simple, définissent un ensemble de réglages du logiciel et de préférences de l’utilisateur. Si vous fermez Rstudio (faites-le !) il vous suffira pour reprendre votre travail là où vous vous étiez arrêté : de lancer R-studio et de cliquer sur File/open project/… suivi du nom du fichier xxx.Rproj ou plus simplement encore de double cliquer sur le fichier xxx.Rproj ce qui lancera automatiquement Rstudio Le dossier contenant votre projet R peut être organisé à votre convenance. Certains mettent tout les fichier pêle-mêle dans le dossier. D’autres préfèrent créer des sous-dossiers contenant des données, des programmes, des résultats, des figures. Vous déciderez à l’usage de ce qui vous convient le mieux, mais le point important est que tout ce qui entre ou sort de vos programmes R doit être de préférence stocké dans le répertoire du projet. 2.2 Programme R : Excel killer ? C’est pourquoi tu quittera Word et Excel, et t’attachera à R studio, et vous deviendrez une seule chair. La fonction initiale d’un langage de programmation comme R est … de créer des programmes c’est-à-dire des ensembles d’instruction permettant d’accomplir une tâche à l’intérieur d’une chaîne de production. Dans le cas d’un logiciel spécialisé dans l’analyse statistique, il s’agira donc de partir de données (statistiques, géographiques, textuelles, …) pour aboutir à des résultats prenant la forme de tableaux, cartes ou graphiques. Il ne s’agit donc en somme que d’une étape du travail de recherche où le principal avantage de R est d’automatiser une tâche et de faciliter sa reproduction ultérieure avec en arrière plan un objectif de productivité puisque l’ordinateur réalise en quelques millisecondes des tâches qui prendraient des heures avec un logiciel click-bouton de type Excel. Prenons un exemple simple de problème facile à résoudre avec R mais plus compliqué avec des logiciels click-boutons. Il s’agit d’un exemple pédagogique tiré d’un très vieux cours d’analyse spatiale portant sur les semis de point et les localisations optimales. On considère une carte papier permettant de localiser 5 station services à l’intérieur d’une ville à plan en damier. Chaque station livre chacune la même quantité de carburant par semaine aux clients. On souhaite répondre aux questions suivantes : Comment saisir les données dans une fichier numérique ? Comment reproduire la carte papier sous forme d’un graphique ? Comment calculer la dsitance à vol d’oiseau entre toutes les stations ? Comment calculer la dsitance routière entre toutes les stations ? Où localiser un dépôt de carburant permettant d’alimenter les cinq stations en minimisant la distance moyenne de livraison (critère d’efficacite) Où localiser une caserne de pompier qui doit pouvoir intervenir rapidement sur toute les stations et qui doit minimiser la distance maximale à la station la plus éloignée (critère d’équité). Comment visualiser ces deux localisations sur la carte des stations ? Comment reproduire ces tâches rapidement s’il y a des ajouts ou suppressions de stations On constitue deux équipes d’étudiants, certains utilisant un programme R et d’autres Excel. On se propose de voir qui ira le plus vite sur chacune des 8 tâches proposées. 2.2.1 Round 1. Saisie des données et affichage du tableau On crée un programme R avec File/New File/R Script puis on l’enregistre avec File/Save/ … suivi du nom du programme. # Saisie des variables CODE &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;) X &lt;- c(10,20,40,50,180) Y &lt;- c(40,60,40,60,50) # Regroupement dans un tableau coo &lt;- data.frame(X,Y) # Ajout du nom des lignes row.names(coo) &lt;- CODE # Affichage du tableau coo #&gt; X Y #&gt; A 10 40 #&gt; B 20 60 #&gt; C 40 40 #&gt; D 50 60 #&gt; E 180 50 Normalement, les étudiants qui utilisent un tableur ont du aller plus vite et Excel mène sur R par 1-0 2.2.2 Round 2. Affichage de la carte Vous devez essayez de reproduire l’image correspondant au problème posé plot(X,Y, col=&quot;red&quot;, pch=20, xlim=c(0,180), ylim=c(0,90), asp = 1) text(X,Y, labels = CODE, pos = 2) La création d’un graphique est à première vue plus facile avec un logiciel click-bouton. L’avantage est très clairement pour Excel qui mène désormais 2 à 0. 2.2.3 Round 3. Calcul de la station la plus accessible à vol d’oiseau (distance euclidienne) Vous devez calculer une matrice de distance euclidienne entre toutes les stations et trouver la plus accessible. # calcul la matrice de distance euclidienne mat&lt;-dist(coo, upper = T, method = &quot;euclidean&quot;) mat #&gt; A B C D E #&gt; A 22.36068 30.00000 44.72136 170.29386 #&gt; B 22.36068 28.28427 30.00000 160.31220 #&gt; C 30.00000 28.28427 22.36068 140.35669 #&gt; D 44.72136 30.00000 22.36068 130.38405 #&gt; E 170.29386 160.31220 140.35669 130.38405 # distance moyenne apply(as.matrix(mat),1,mean) #&gt; A B C D E #&gt; 53.47518 48.19143 44.20033 45.49322 120.26936 Là, je parie que les utilisateurs d’Excel ont eu un peu plus de mal … En tous les cas, Excel ne mèneplus que par 2 à 1 2.2.4 Round 4. Calcul de la station la plus accessible par la route (distance de Manhattan) Vous devez calculer une matrice de distance de Manhattan entre toutes les stations et trouver la plus accessible. # calcul la matrice de distance de Manhattan mat&lt;-dist(coo,upper = T, method = &quot;manhattan&quot;) mat #&gt; A B C D E #&gt; A 30 30 60 180 #&gt; B 30 40 30 170 #&gt; C 30 40 30 150 #&gt; D 60 30 30 140 #&gt; E 180 170 150 140 # distance moyenne de Manhattan apply(as.matrix(mat),1,mean) #&gt; A B C D E #&gt; 60 54 50 52 128 Je reconnais que c’est unpeu facile, mais à nouveau R l’emporte ce qui fait désormais match nul 2-2 2.2.5 Round 5. Localisation du dépôt de carburant Dans le cas particulier de la distance de Manhattan, le calcul du point le plus proche de tous les autres s’obtient facilement en calculant le point médian dont les coordonnées correspondent à la médiane de X et la médiane de Y. medX &lt;- median(X) medX #&gt; [1] 40 medY &lt;- median(Y) medY #&gt; [1] 50 A priori, le calcul est aussi facile dans R et dans Excel : match nul 3-3 2.2.6 Round 6. Localisation de la caserne de pompiers Dans le cas particulier de la distance de Manhattan, le calcul du point minimisant la distance maximale s’obtient en trouvant le centre du diamètre minimal en X et en Y. Il s’agit de la localisation la plus équitable où le plus défavorisé est le moins défavorisé possible. equX &lt;- (max(X)+min(X))/2 equX #&gt; [1] 95 equY &lt;- (max(Y)+min(Y))/2 equY #&gt; [1] 50 A priori, le calcul est toujours aussi facile dans R et dans Excel : match nul 4-4 2.2.7 Round 7. Visualisation des deux points sur la carte On va placer en bleu le point médian et en vert le point le plus équitable. Dans le cas de R on peut recopier les lignes de code du graphique du round n°2 ce qui gagne désormais du temps : # Programme antérieur plot(X,Y, col=&quot;red&quot;, pch=20, xlim=c(0,180), ylim=c(0,90), asp = 1) text(X,Y, labels = CODE, pos = 2) # Ajout du dépôt de carburant points(medX, medY, col=&quot;blue&quot;, pch=3) text(medX,medY, &quot;dépot&quot;,pos=1) # Ajout du point médian points(equX, equY, col=&quot;green&quot;, pch=3) text(equX,equY, &quot;caserne&quot;,pos=1) Le résultat du match est incertain mais R n’est plus désavantagé puisqu’on peut recycler les lignes de code précédentes pour le graphique de base. Disons 5-5 même s’il y a de fortes chances que R l’emporte. 2.2.8 Dernier round. Refaire toute l’analyse avec une station de plus Deux stations F(100,20) et G(150,30) ont été ajoutées. Il faut refaire la carte finale. Cela ne pose aucun problème dans R puisqu’il suffit de modifier l’entrée des données et récupérer des bouts de programme # (1) Saisie des variables CODE &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;) X &lt;- c(10,20,40,50,180,100,150) Y &lt;- c(40,60,40,60,50,20,30) coo &lt;- data.frame(X,Y) row.names(coo) &lt;- CODE # (2) calcul des points centraux medX &lt;- median(X) medY &lt;- median(Y) equX &lt;- (max(X)+min(X))/2 equY &lt;- (max(Y)+min(Y))/2 # (3) Graphique plot(X,Y, col=&quot;red&quot;, pch=20, xlim=c(0,180), ylim=c(0,90), asp = 1) text(X,Y, labels = CODE, pos = 2) # Ajout du dépôt de carburant points(medX, medY, col=&quot;blue&quot;, pch=3) text(medX,medY, &quot;Dépôt&quot;,pos=1) # Ajout du point médian points(equX, equY, col=&quot;green&quot;, pch=3) text(equX,equY, &quot;Caserne&quot;,pos=1) Excel n’a aucune chance d’aller plus vite et R remporte le match par KO ! 2.3 Document Rmd : Word killer ? R-Studio dit : « Faisons une interface de rédaction adaptée à notre travail, Que l’utilisateur puissent y insérer les tableaux, les graphiques, les cartes, les références bibliographiques, et tous les écrits qui les commentent. » Nous venons de voir comment une bonne pratique de R peut conduire progressivement à abandonner l’usage des tableurs (Excel, Open Office) sauf peut-être pour l’étape de saisie des données. Dès lors qu’il s’agit de réaliser des graphiques ou des calculs statistiques complexes, la rédaction d’un programme se révèle beaucoup plus intéressante même si elle impose un coût initial d’apprentissage. Mais une bonne pratique de R ou plus précisément des documents R markdown peut vous conduire beaucoup plus loin et vous amener à abandonner également votre logiciel de traitement de texte (Word) et votre outil de présentation (Power Point). Le coût d’apprentissage est naturellement un peu plus élevé mais les bénéfices sont à la mesure de l’investissement. Comme le montre la figure ci-dessous, un document R markdown est en quelques sorte un mélange entre des lignes de code R qui executent des tâches et des lignes de texte où sont expliqués les calculs et commentés les résultats obtenus. En d’autres termes, un document R markdown vous permet de rédiger un article de recherche complet, une présentation à une conférence, un syllabus de cours, dans un seul environnement logiciel (R studio). Nul besoin de ciseau et de colle pour aller chercher tel tableau ici, tel figure là-bas ou telle carte ailleurs. Tous ces éléments sont intégrs au fur et à mesure de la rédaction ce qui facilite considérablement la concentration. Et surtout - on l’a déjà vu pour le programme R - le document peut facilement être reproduit ou mise à jour sans être obligé de réplique des dizaines de click de souris. Nous allons illustrer l’usage de R markdown en rédigeant une courte note sur la distribution de la population et de certains commerces et services à Rennes. L’exemple est repris du Manuel d’analyse spatiale publié par l’INSEE en 2018 et plus précisement de son chapitre 4. Les configurations de points Comme nous avons pris la perspective de n’employer aucun package R au cours de cette formation initiale, les données ont été légèrement modifiées, notamment pour le tracé de la carte des contours de la ville de Rennes. 2.3.1 Chargement des données Nous disposons de trois fichiers qui comportent chacun des coordonnées de localisation utilisant la même projection Lambert et que l’on pourra de ce fait superposer. Après les avoir chargés et décrits, on en propose une première visualisation à l’aide des fonctions graphiques de base de R. 2.3.1.1 Contour de Rennes On charge le fichier avec read.table() puis on affiche ses premières lignes avec head()et on regarde sa taille avec dim() map &lt;- read.table(file = &quot;resources/data/rennes/map.csv&quot;, header = T, sep = &quot;;&quot;) head(map,2) #&gt; x y #&gt; 1 346382.1 6786334 #&gt; 2 346460.0 6786704 dim(map) #&gt; [1] 37 2 On affiche le contour avec les instructions plot() et lines(). On doit impérativement ajouter le paramètre asp = 1 dans plot() pour imposer une échelle identique sur l’axe vertical et l’axe horizontal. plot(map$x,map$y, col=&quot;red&quot;, asp = 1) lines(map$x,map$y, col=&quot;blue&quot;) 2.3.1.2 Distribution de la population On charge le fichier de population de la même manière et on constate qu’il comporte une troisième colonne indiquant la population localisée en chaque point. En fait, il s’agit d’une grille de population qui localise les habitants sur une maille de ??? m pop &lt;- read.table(file = &quot;resources/data/rennes/popu.csv&quot;, header = T, sep = &quot;;&quot;) head(pop,2) #&gt; x y pop #&gt; 1 346202.1 6790631 20 #&gt; 2 346203.4 6792843 5 dim(pop) #&gt; [1] 24916 3 On procède à une première cartographie qui ne tient pas compte de l’effectif de population mais indique juste les cases occupées et inoccupées, ce qui permet de donner une vision générale de l’occuparion du sol et du peuplement de Rennes et de l’espace environnant. plot(pop$x,pop$y, col=&quot;red&quot;, asp = 1,pch=22, cex=0.01) lines(map$x,map$y, col=&quot;black&quot;) #### Distribution des équipements L’INSEE a extrait du fichier de la Base Publique des Equipements quatre types de localisations correspondant aux écoles, aux médecins, aux pharmacies et aux commerces de vêtements. On notera l’ajout du paramètre encoding=“UTF-8” qui permet de lire sans erreur les caractères accentués et d’éviter par exemple que “Vêtements” devienne “VÃªtements”. bpe &lt;- read.table(file = &quot;resources/data/rennes/bpe.csv&quot;, header = T, sep = &quot;;&quot;, encoding=&quot;UTF-8&quot;) head(bpe,2) #&gt; x y equ #&gt; 286 349156.2 6790525 Ecoles #&gt; 287 351800.4 6786774 Ecoles dim(bpe) #&gt; [1] 767 3 On utilise l’instruction table()pour dénombrer l’effectif de chaque équipement : table(bpe$equ) #&gt; #&gt; Ecoles Médecins Pharmacies Vêtements #&gt; 59 268 70 370 Puis on visualise après avoir attribué une couleur à chaque équipement. On crée pour cela une nouvelle variable : bpe$couleur&lt;-as.factor(bpe$equ) levels(bpe$couleur) #&gt; [1] &quot;Ecoles&quot; &quot;Médecins&quot; &quot;Pharmacies&quot; &quot;Vêtements&quot; levels(bpe$couleur)&lt;-c(&quot;blue&quot;,&quot;green&quot;,&quot;orange&quot;,&quot;red&quot;) bpe$couleur&lt;-as.character(bpe$couleur) table(bpe$couleur) #&gt; #&gt; blue green orange red #&gt; 59 268 70 370 On peut désormais assembler nos trois couches : plot(pop$x,pop$y, col=&quot;gray&quot;, asp = 1,pch=22, cex=0.01) lines(map$x,map$y, col=&quot;black&quot;) points(bpe$x,bpe$y,bg=bpe$couleur, pch=21, cex=0.8) Il est facile de procéder à un zoom en ajoutant des paramètres xlim et ylim dans la fonction plot() qui précise l’espace d’étude. plot(pop$x, pop$y, col=&quot;gray&quot;, asp = 1, pch=22, cex=0.1, xlim = c(351000,353000), ylim = c(6788500,6790500)) lines(map$x, map$y, col=&quot;black&quot;) points(bpe$x, bpe$y, bg=bpe$couleur, pch=21, cex=0.8) OK, notre carte n’a pas de légende (c’est possible mais vraiment compliqué en R-Base) mais on appréciera le fait d’avoir pu la réaliser en ne se servant que de quelques fonctions élémentaires de R comme 2.3.2 A vous de jouer ! En vous inspirant de l’exemple des stations services, essayez de définir un certain nombre de questions et tentez d’y répondre … 2.4 En résumé R est un Excel killer mais aussi un Word killer voire un Power point killer… Adopter R peut nuire gravement à vos habitudes antérieures de travail. 2.5 Exercices Exercice 1 Construire le vecteur x suivant : #&gt; [1] &quot;Paris&quot; &quot;Londres&quot; &quot;Tokyo&quot; &quot;New York&quot; x &lt;- c(&quot;Paris&quot;, &quot;Londres&quot;,&quot;Tokyo&quot;,&quot;New York&quot;) Construire le vecteur y suivant : #&gt; [1] &quot;France&quot; &quot;Royaume-Uni&quot; &quot;Japon&quot; &quot;USA&quot; y &lt;- c(&quot;France&quot;, &quot;Royaume-Uni&quot;,&quot;Japon&quot;,&quot;USA&quot;) Construire le vecteur z suivant : #&gt; [1] 10.2 14.6 42.8 23.9 z &lt;- c(10.2, 14.6,42.8,23.9) Construire la matrice m1 #&gt; [,1] [,2] [,3] [,4] #&gt; x &quot;Paris&quot; &quot;Londres&quot; &quot;Tokyo&quot; &quot;New York&quot; #&gt; y &quot;France&quot; &quot;Royaume-Uni&quot; &quot;Japon&quot; &quot;USA&quot; m1&lt;-rbind(x,y) Construire le data.frame df #&gt; y x z #&gt; 1 France Paris 10.2 #&gt; 2 Royaume-Uni Londres 14.6 #&gt; 3 Japon Tokyo 42.8 #&gt; 4 USA New York 23.9 df&lt;-data.frame(y,x,z) Exercice 2 (d’après J.Barnier) On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage. revenu_total &lt;- conjoint1 + conjoint2 revenu_total / nb_personnes "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
